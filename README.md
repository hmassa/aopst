# Access Optimized Priority Search Tree
## Abstract
The priority search tree is a data structure introduced by Edward McCreight in 1985 with the primary purpose of storing a set of n points in ℝ² in a way that allows insertion, 
deletion, and various search algorithms to have an average and worst case time complexity of O(log n). This ideal complexity is achieved by combining the completeness of heaps 
with the efficient search algorithm of binary search trees. Because of these properties, and as we will show in this paper, priority search trees can be slightly altered to 
improve upon splay trees. The structural adjustments that result in this improvement include storing elements of the data set to be searched in the x-coordinate and the number 
of times the element has been accessed in the y-coordinate of a maximum priority search tree node. Like splay trees, this new data structure, which we will call an access 
optimized priority search tree, utilizes the principle of locality that is so often seen in computing. However, whereas splay trees have a worst case complexity of  O(n) for 
searching, access optimized priority search trees manage to reduce this worst case to O(log n) while preserving splay trees’ average time complexity.

## Current Tests
Currently, I have compared the search performance of a splay tree and an access optimized search tree on 7 different datasets. These datasets include a Benford distribution, a Zipf distribution, a uniform distribution, a normal distribution, and a Pareto distribution. The final two datasets tested are the letters from a song's lyrics and the words in the "Star Wars: Episode IV - A New Hope" movie sript. Search performance is based on the number of comparisons required to find the search key in each tree and resturucturing, if necessary. The data from these tests can be found in the "aopst_vs_splay.xlsx" file in the Results folder.
In addition, all of these tests were repeated, only this time comparing the performance of the AOPST against that of a Balanced BST. The data from these tests can be found in the "aopst_vs_bst.xlsx" file in the Results folder.
The last file in the Results folder, titled "construction.xlsx", compares the performance of two differently structured AOPSTs. The first structure starts by building a tree where the priority of every node starts at 0. Then, every time a node is accessed via search the priority is incremented by 1 and the tree is restructured, if necessary, to fulfill the structural requirements of a priority search tree. The code for this structure is in the "RestructuringAOPST.java" file in the src folder. The second structure first runs through all of the search keys and counts the number of occurences of each unique key. Then, a tree is built using the number of occurences as the priority for each node. This way, the tree does not need to be restructured during runtime. The code for this implementation is in the "StaticAOPST.java" file in the src folder. Several of the above tests were run comparing these two structures and the results of these tests indicate that the static AOPST typically outperforms the restructuring version in searching, however this does come at the cost of a potentially greater construction time. 


